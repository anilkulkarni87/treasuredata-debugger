// panel.js â€” clean, single-definition, MV3-safe

/**
 * @typedef {import('./types.js').Entry} Entry
 * @typedef {import('./types.js').TDInfo} TDInfo
 * @typedef {import('./types.js').Extractor} Extractor
 * @typedef {import('./types.js').ExtractorContext} ExtractorContext
 */

import { defaultExtractors } from './parsers.js';

/**
 * Get element by ID
 * @param {string} id - Element ID
 * @returns {HTMLElement|null} Element or null
 */
const $ = (id) => document.getElementById(id);

// ---------- helpers ----------
/**
 * Check if content type is JSON-like
 * @param {string} ct - Content-Type header value
 * @returns {boolean} True if JSON-like
 */
function isJsonLike(ct) {
  if (!ct) return false;
  const v = ct.toLowerCase();
  return v.includes('application/json') || v.includes('text/json') || /\+json\b/.test(v);
}
/**
 * Mask authorization header value for privacy
 * @param {string} v - Authorization header value
 * @returns {string} Masked value
 */
function maskAuthorization(v) {
  if (!v || typeof v !== 'string') return v;
  const parts = v.split(/\s+/);
  if (parts.length < 2) return '****';
  const scheme = parts[0];
  const token = parts.slice(1).join(' ');
  const vis = token.slice(0, 8);
  return `${scheme} ${vis}â€¦ (masked)`;
}

// define-once guard to avoid â€œalready declaredâ€ if file ever gets injected twice
if (!window.__td_isPreflight) {
  window.__td_isPreflight = function (req) {
    const method = req.request && req.request.method;
    if (method !== 'OPTIONS') return false;
    const hdrs = (req.request && req.request.headers) || [];
    return hdrs.some((h) => (h.name || '').toLowerCase() === 'access-control-request-method');
  };
}
const isPreflight = window.__td_isPreflight;

// ---------- state ----------
const state = {
  entries: [],
  counter: 0,
  hosts: [],
  showNonTD: false,
  showPreflight: false,
  maxVisible: 100, // Performance: limit visible entries
  currentPage: 0, // Performance: current page for pagination
};

let extractors = [...defaultExtractors];

async function loadCustomExtractors() {
  try {
    const mod = await import(chrome.runtime.getURL('custom-extractors.js'));
    const extra = (mod && (mod.default || mod.extractors)) || [];
    if (Array.isArray(extra) && extra.length) extractors = [...extra, ...extractors];
  } catch { }
}

/**
 * Check if URL matches configured TD hosts
 * @param {string} url - Request URL
 * @returns {boolean} True if matches TD hosts
 */
function isTDRequest(url) {
  try {
    const u = new URL(url);
    return state.hosts.some((h) => u.host.endsWith(h));
  } catch {
    return false;
  }
}
/**
 * Extract Treasure Data metadata from URL and headers
 * @param {string} url - Request URL
 * @param {Array<{name: string, value: string}>} headersList - Request headers
 * @returns {TDInfo} Extracted metadata
 */
function extractTDInfo(url, headersList) {
  const out = {};
  try {
    const u = new URL(url);
    out.host = u.host;
    out.pathname = u.pathname || '';
    out.query = Object.fromEntries(u.searchParams.entries());
    const parts = out.pathname.replace(/^\/+/, '').split('/');
    if (parts.length >= 2) {
      out.database = parts[0];
      out.table = parts[1];
    }
    const hp = out.host.split('.');
    if (hp.length >= 4) {
      out.region = hp[0];
      out.edge = hp[1];
    }
    if (Array.isArray(headersList)) {
      const headers = {};
      for (const h of headersList) {
        const name = (h.name || '').toLowerCase();
        if (
          name === 'content-type' ||
          name === 'accept' ||
          name === 'origin' ||
          name.startsWith('sec-ch-ua')
        ) {
          headers[name] = h.value;
        }
        if (name === 'authorization') headers[name] = maskAuthorization(h.value);
      }
      if (Object.keys(headers).length) out.headers = headers;
    }
  } catch { }
  return out;
}
/**
 * Merge two parsed objects
 * @param {any} a - First object
 * @param {any} b - Second object
 * @returns {any} Merged result
 */
function mergeParsed(a, b) {
  if (!a) return b;
  if (!b) return a;
  if (typeof a === 'object' && typeof b === 'object') return { ...a, ...b };
  return a;
}

// ---------- prefs / redaction ----------
function loadPrefs() {
  chrome.storage.sync.get(
    ['tdHosts', 'showNonTD', 'tdFilter', 'tdRedact', 'showPreflight'],
    (res) => {
      if (Array.isArray(res.tdHosts) && res.tdHosts.length) state.hosts = res.tdHosts;
      if (typeof res.showNonTD === 'boolean') state.showNonTD = res.showNonTD;
      state.showPreflight = !!res.showPreflight;

      const hostsInput = $('hosts');
      if (hostsInput) hostsInput.value = state.hosts.join(', ');
      const nonTD = $('showNonTD');
      if (nonTD) nonTD.checked = state.showNonTD;
      const pre = $('showPreflight');
      if (pre) pre.checked = state.showPreflight;
      const filt = $('filter');
      if (filt) filt.value = res.tdFilter || '';
      const red = $('redact');
      if (red) red.checked = !!res.tdRedact;
    }
  );
}
function savePrefs() {
  const hostsInput = $('hosts');
  const nonTD = $('showNonTD');
  const pre = $('showPreflight');
  const filt = $('filter');
  const red = $('redact');

  const hosts = hostsInput
    ? hostsInput.value
      .split(',')
      .map((h) => h.trim())
      .filter(Boolean)
    : [];
  state.hosts = hosts.length ? hosts : ['in.treasuredata.com'];
  state.showNonTD = !!(nonTD && nonTD.checked);
  state.showPreflight = !!(pre && pre.checked);

  chrome.storage.sync.set({
    tdHosts: state.hosts,
    showNonTD: state.showNonTD,
    showPreflight: state.showPreflight,
    tdFilter: filt ? filt.value : '',
    tdRedact: !!(red && red.checked),
  });
}

function getBuiltInPatterns() {
  return [
    { re: /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/gi, sub: '***@***' },
    { re: /\b([A-F0-9]{32,}|[A-Za-z0-9_\-]{24,})\b/g, sub: '****' },
  ];
}
/**
 * Load custom redaction rules from storage
 * @returns {Promise<Array<{re: RegExp, sub: string}>>} Compiled redaction patterns
 */
function loadRedactionRules() {
  return new Promise((resolve) =>
    chrome.storage.sync.get(['redactionRules'], (res) => {
      const lines = Array.isArray(res.redactionRules) ? res.redactionRules : [];
      const compiled = [];
      for (const line of lines) {
        const s = String(line || '').trim();
        if (!s) continue;
        try {
          compiled.push({ re: new RegExp(s, 'g'), sub: '****' });
        } catch { }
      }
      resolve(compiled);
    })
  );
}
/**
 * Redact PII from object using built-in and custom rules
 * @param {any} obj - Object to redact
 * @returns {Promise<any>} Redacted object
 */
async function redactPII(obj) {
  const custom = await loadRedactionRules();
  const patterns = [...getBuiltInPatterns(), ...custom];
  function rec(x) {
    if (Array.isArray(x)) return x.map(rec);
    if (x && typeof x === 'object') {
      const o = {};
      for (const k of Object.keys(x)) o[k] = rec(x[k]);
      return o;
    }
    if (typeof x === 'string') {
      let s = x;
      for (const p of patterns) s = s.replace(p.re, p.sub);
      return s;
    }
    return x;
  }
  return rec(obj);
}
/**
 * Load custom fields configuration from storage
 * @returns {Promise<Record<string, import('./types.js').ExtractorConfig>>} Custom fields config
 */
function loadCustomFields() {
  return new Promise((resolve) =>
    chrome.storage.sync.get(['customFields'], (r) => resolve(r.customFields || {}))
  );
}

// ---------- parsing ----------
/**
 * Parse request/response payload using extractors
 * @param {string} contentType - Content-Type header
 * @param {string} rawText - Raw body text
 * @returns {Promise<any>} Parsed and summarized payload
 */
async function parsePayload(contentType, rawText) {
  if (!rawText) return null;

  // JSON
  if (isJsonLike(contentType)) {
    try {
      const bodyObj = JSON.parse(rawText);
      const customFields = await loadCustomFields();
      const ctx = { bodyObj, customFields };
      const ext =
        extractors.find((e) => {
          try {
            return e.match(ctx);
          } catch {
            return false;
          }
        }) || extractors[extractors.length - 1];
      try {
        return ext.summarize(ctx);
      } catch {
        return bodyObj;
      }
    } catch { }
  }

  // x-www-form-urlencoded
  if (contentType && contentType.includes('application/x-www-form-urlencoded')) {
    const params = new URLSearchParams(rawText);
    const obj = {};
    for (const [k, v] of params.entries()) {
      try {
        obj[k] = JSON.parse(v);
      } catch {
        obj[k] = v;
      }
    }
    const customFields = await loadCustomFields();
    const ctx = { bodyObj: obj, customFields };
    const ext =
      extractors.find((e) => {
        try {
          return e.match(ctx);
        } catch {
          return false;
        }
      }) || extractors[extractors.length - 1];
    try {
      return ext.summarize(ctx);
    } catch {
      return obj;
    }
  }

  // NDJSON / first-line JSON guess
  if (rawText.includes('\n')) {
    const first = rawText.split('\n').find((l) => l.trim().length) || '';
    try {
      const bodyObj = JSON.parse(first);
      const customFields = await loadCustomFields();
      const ctx = { bodyObj, customFields };
      const ext =
        extractors.find((e) => {
          try {
            return e.match(ctx);
          } catch {
            return false;
          }
        }) || extractors[extractors.length - 1];
      try {
        return ext.summarize(ctx);
      } catch {
        return bodyObj;
      }
    } catch { }
  }

  // fallback: trimmed string
  return rawText.length > 500 ? rawText.slice(0, 500) + ' â€¦' : rawText;
}

// ---------- table render ----------
/**
 * Check if entry matches filter query
 * @param {Entry} entry - Entry to check
 * @param {string} q - Filter query
 * @returns {boolean} True if matches
 */
function matchesFilter(entry, q) {
  // Status filter
  const statusFilter = $('statusFilter')?.value;
  if (statusFilter) {
    const status = String(entry.status);
    if (statusFilter === '2xx' && !status.startsWith('2')) return false;
    if (statusFilter === '3xx' && !status.startsWith('3')) return false;
    if (statusFilter === '4xx' && !status.startsWith('4')) return false;
    if (statusFilter === '5xx' && !status.startsWith('5')) return false;
  }

  // Database filter
  const dbFilter = $('dbFilter')?.value;
  if (dbFilter && entry.parsed?.database !== dbFilter) return false;

  // Text/regex filter
  if (!q) return true;

  const hay = (entry.url + ' ' + JSON.stringify(entry.parsed)).toLowerCase();
  const isRegex = $('regexFilter')?.checked;

  if (isRegex) {
    try {
      const re = new RegExp(q, 'i');
      return re.test(hay);
    } catch {
      // Invalid regex - fail silently, user will see no results
      return false;
    }
  }

  return hay.includes(q.toLowerCase());
}
function clearTable() {
  const body = $('reqBody');
  if (body) body.innerHTML = '';
}

/**
 * Update database filter dropdown with unique databases
 */
function updateDatabaseFilter() {
  const databases = new Set();
  state.entries.forEach((e) => {
    if (e.parsed?.database) databases.add(e.parsed.database);
  });

  const dbFilter = $('dbFilter');
  if (dbFilter) {
    const currentValue = dbFilter.value;
    dbFilter.innerHTML = '<option value="">All Databases</option>';
    Array.from(databases)
      .sort()
      .forEach((db) => {
        const opt = document.createElement('option');
        opt.value = db;
        opt.textContent = db;
        dbFilter.appendChild(opt);
      });
    // Restore previous selection if still valid
    if (currentValue && databases.has(currentValue)) {
      dbFilter.value = currentValue;
    }
  }
}

/**
 * Append a row to the table for an entry
 * @param {Entry} entry - Entry to render
 * @returns {Promise<void>}
 */
async function appendRow(entry) {
  const tpl = $('rowTemplate');
  if (!tpl) return;

  const redactCheckbox = $('redact');
  const doRedact = !!(redactCheckbox && redactCheckbox.checked);

  let parsed = entry.parsed;
  if (doRedact && parsed && typeof parsed === 'object') {
    try {
      parsed = await redactPII(parsed);
    } catch { }
  }

  const frag = tpl.content.cloneNode(true);
  frag.querySelector('.idx').textContent = entry.idx;
  frag.querySelector('.time').textContent = new Date(entry.time).toLocaleTimeString();
  frag.querySelector('.method').textContent = entry.method || '';
  frag.querySelector('.url').textContent = entry.url || '';
  frag.querySelector('.status').textContent = entry.status || '';
  frag.querySelector('.ct').textContent = entry.contentType || '';

  const row = frag.querySelector('tr');
  if (entry.preflight) row.classList.add('preflight');
  if (entry.status >= 200 && entry.status < 300) row.classList.add('status-2xx');
  else if (entry.status >= 400) row.classList.add('status-4xx');

  const cell = frag.querySelector('.parsed');
  if (typeof parsed === 'object') {
    const pre = document.createElement('pre');
    pre.textContent = JSON.stringify(parsed, null, 2);
    cell.appendChild(pre);
  } else if (typeof parsed === 'string') {
    const pre = document.createElement('pre');
    pre.textContent = parsed;
    cell.appendChild(pre);
  }

  // Add headers button
  const headersCell = frag.querySelector('.headers-cell');
  if (headersCell && (entry.requestHeaders || entry.responseHeaders)) {
    const headersBtn = document.createElement('button');
    headersBtn.className = 'btn';
    headersBtn.textContent = 'ðŸ“‹ Headers';
    headersBtn.style.fontSize = '11px';
    headersBtn.addEventListener('click', () => showHeadersModal(entry));
    headersCell.appendChild(headersBtn);
  }

  const body = $('reqBody');
  if (body) body.prepend(frag);
}
async function renderTable() {
  clearTable();
  const filterInput = $('filter');
  const q = filterInput ? filterInput.value.trim() : '';
  const filtered = state.entries.filter((e) => matchesFilter(e, q));

  // Performance: Pagination
  const start = state.currentPage * state.maxVisible;
  const end = start + state.maxVisible;
  const visible = filtered.slice(start, end);

  // Show pagination info
  const paginationInfo = $('paginationInfo');
  if (paginationInfo) {
    if (filtered.length > state.maxVisible) {
      const showing = Math.min(visible.length, filtered.length);
      paginationInfo.textContent = `Showing ${showing} of ${filtered.length} entries`;
      paginationInfo.style.display = 'inline';
    } else {
      paginationInfo.style.display = 'none';
    }
  }

  // Update pagination buttons
  const prevBtn = $('prevPage');
  const nextBtn = $('nextPage');
  if (prevBtn) prevBtn.disabled = state.currentPage === 0;
  if (nextBtn) nextBtn.disabled = end >= filtered.length;

  for (const e of visible.slice().reverse()) {
    await appendRow(e);
  }
}

// ---------- network capture ----------
function attachNetworkListener() {
  chrome.devtools.network.onRequestFinished.addListener(async (req) => {
    try {
      if (!state.showPreflight && isPreflight(req)) return;

      const url = req.request && req.request.url;
      const method = req.request && req.request.method;
      const isTD = isTDRequest(url);
      if (!isTD && !state.showNonTD) return;

      const postData = (req.request && req.request.postData && req.request.postData.text) || '';
      const requestHeaders = (req.request && req.request.headers) || [];
      const ctHdr = requestHeaders.find((h) => (h.name || '').toLowerCase() === 'content-type');
      const requestCT = ctHdr && ctHdr.value;

      const status = (req.response && req.response.status) || '';
      const respCT = ((req.response && req.response.headers) || []).find(
        (h) => (h.name || '').toLowerCase() === 'content-type'
      );
      const contentType = requestCT || (respCT && respCT.value) || '';

      const idx = ++state.counter;
      const time = Date.now();

      const urlInfo = extractTDInfo(url, requestHeaders);

      const finalize = async (bodyTextFromResp) => {
        try {
          const raw = postData || bodyTextFromResp || '';
          let bodyParsed;

          try {
            bodyParsed = await parsePayload(contentType, raw);
          } catch (parseErr) {
            console.error('[TD Debugger] Parse error:', {
              url,
              contentType,
              error: parseErr.message,
              stack: parseErr.stack,
            });
            bodyParsed = {
              __error__: `Parse failed: ${parseErr.message}`,
              __raw_preview__: raw.slice(0, 200),
            };
          }

          const tdSummary = {
            ...(urlInfo.database && { database: urlInfo.database }),
            ...(urlInfo.table && { table: urlInfo.table }),
            ...(urlInfo.region && { region: urlInfo.region }),
            ...(urlInfo.edge && { edge: urlInfo.edge }),
            ...(urlInfo.query && Object.keys(urlInfo.query).length ? { query: urlInfo.query } : {}),
            ...(urlInfo.pathname && { path: urlInfo.pathname }),
            ...(urlInfo.headers && { headers: urlInfo.headers }),
          };

          const combined = mergeParsed(tdSummary, bodyParsed);

          state.entries.push({
            idx,
            time,
            method,
            url,
            status,
            contentType,
            parsed: combined,
            preflight: method === 'OPTIONS',
            requestHeaders: req.request?.headers || [],
            responseHeaders: req.response?.headers || [],
          });

          await renderTable();
          updateDatabaseFilter(); // Update database filter dropdown
        } catch (finalizeErr) {
          console.error('[TD Debugger] Finalize error:', {
            url,
            error: finalizeErr.message,
            stack: finalizeErr.stack,
          });
          // Still add entry with error state
          state.entries.push({
            idx,
            time,
            method,
            url,
            status,
            contentType,
            parsed: { __error__: `Processing failed: ${finalizeErr.message}` },
            preflight: method === 'OPTIONS',
            requestHeaders: req.request?.headers || [],
            responseHeaders: req.response?.headers || [],
          });
          await renderTable();
        }
      };

      if (!postData) {
        req.getContent((body) => finalize(body || ''));
      } else {
        finalize('');
      }
    } catch (err) {
      console.error('[TD Debugger] Network listener error:', {
        error: err.message,
        stack: err.stack,
      });
    }
  });
}


// ---------- UI wiring ----------
(function wireHandlers() {
  const clearBtn = $('clearBtn');
  if (clearBtn)
    clearBtn.addEventListener('click', () => {
      state.entries = [];
      clearTable();
    });

  const hostsInput = $('hosts');
  if (hostsInput) hostsInput.addEventListener('change', savePrefs);
  const nonTD = $('showNonTD');
  if (nonTD) nonTD.addEventListener('change', savePrefs);
  const pre = $('showPreflight');
  if (pre) pre.addEventListener('change', savePrefs);

  const filterInput = $('filter');
  if (filterInput)
    filterInput.addEventListener('input', () => {
      chrome.storage.sync.set({ tdFilter: filterInput.value });
      renderTable();
    });

  const red = $('redact');
  if (red)
    red.addEventListener('change', () => {
      chrome.storage.sync.set({ tdRedact: red.checked });
      renderTable();
    });

  // Advanced filters
  const statusFilter = $('statusFilter');
  if (statusFilter) {
    statusFilter.addEventListener('change', () => {
      state.currentPage = 0; // Reset to first page
      renderTable();
    });
  }

  const dbFilter = $('dbFilter');
  if (dbFilter) {
    dbFilter.addEventListener('change', () => {
      state.currentPage = 0; // Reset to first page
      renderTable();
    });
  }

  const regexFilter = $('regexFilter');
  if (regexFilter) {
    regexFilter.addEventListener('change', () => {
      renderTable();
    });
  }

  const clearFilters = $('clearFilters');
  if (clearFilters) {
    clearFilters.addEventListener('click', () => {
      const filterInput = $('filter');
      if (filterInput) filterInput.value = '';
      if (statusFilter) statusFilter.value = '';
      if (dbFilter) dbFilter.value = '';
      if (regexFilter) regexFilter.checked = false;
      state.currentPage = 0;
      renderTable();
      showToast('Filters cleared', 'success');
    });
  }

  // Filter presets
  const saveFilterPreset = $('saveFilterPreset');
  const filterPresets = $('filterPresets');

  // Populate presets dropdown on load
  function updateFilterPresets() {
    chrome.storage.sync.get(['filterPresets'], (res) => {
      const presets = res.filterPresets || {};
      if (filterPresets) {
        filterPresets.innerHTML = '<option value="">Load Preset...</option>';
        Object.keys(presets)
          .sort()
          .forEach((name) => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.textContent = name;
            filterPresets.appendChild(opt);
          });
      }
    });
  }

  // Save current filter state as preset
  if (saveFilterPreset) {
    saveFilterPreset.addEventListener('click', () => {
      const name = prompt('Enter preset name:');
      if (!name || !name.trim()) return;

      const preset = {
        text: $('filter')?.value || '',
        status: statusFilter?.value || '',
        database: dbFilter?.value || '',
        regex: $('regexFilter')?.checked || false,
      };

      chrome.storage.sync.get(['filterPresets'], (res) => {
        const presets = res.filterPresets || {};
        presets[name.trim()] = preset;
        chrome.storage.sync.set({ filterPresets: presets }, () => {
          updateFilterPresets();
          showToast(`Saved filter preset: ${name}`, 'success');
        });
      });
    });
  }

  // Load preset
  if (filterPresets) {
    filterPresets.addEventListener('change', (e) => {
      const name = e.target.value;
      if (!name) return;

      chrome.storage.sync.get(['filterPresets'], (res) => {
        const preset = res.filterPresets?.[name];
        if (preset) {
          const filterInput = $('filter');
          if (filterInput) filterInput.value = preset.text || '';
          if (statusFilter) statusFilter.value = preset.status || '';
          if (dbFilter) dbFilter.value = preset.database || '';
          const regexCheckbox = $('regexFilter');
          if (regexCheckbox) regexCheckbox.checked = preset.regex || false;

          state.currentPage = 0;
          renderTable();
          showToast(`Loaded filter preset: ${name}`, 'success');

          // Reset dropdown
          filterPresets.value = '';
        }
      });
    });

    // Right-click to delete preset
    filterPresets.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const name = filterPresets.value;
      if (!name) {
        showToast('Select a preset to delete', 'warning');
        return;
      }

      if (confirm(`Delete preset "${name}"?`)) {
        chrome.storage.sync.get(['filterPresets'], (res) => {
          const presets = res.filterPresets || {};
          delete presets[name];
          chrome.storage.sync.set({ filterPresets: presets }, () => {
            updateFilterPresets();
            showToast(`Deleted preset: ${name}`, 'success');
          });
        });
      }
    });

    // Initialize presets dropdown
    updateFilterPresets();
  }

  const exportCsvBtn = $('exportCsv');
  if (exportCsvBtn)
    exportCsvBtn.addEventListener('click', () => {
      const rows = [
        [
          'idx',
          'time',
          'method',
          'status',
          'url',
          'database',
          'table',
          'td_client_id',
          'td_global_id',
          'td_ecomm_event_type',
        ],
      ];
      const qInput = $('filter');
      const q = qInput ? qInput.value.trim() : '';
      const filtered = state.entries.filter((e) => matchesFilter(e, q));
      for (const e of filtered) {
        const p = e.parsed && typeof e.parsed === 'object' ? e.parsed : {};
        const s = Array.isArray(p.sample) && p.sample.length ? p.sample[0] : {};
        rows.push([
          e.idx,
          new Date(e.time).toISOString(),
          e.method || '',
          e.status || '',
          e.url || '',
          p.database || '',
          p.table || '',
          s.td_client_id || '',
          s.td_global_id || '',
          s.td_ecomm_event_type || '',
        ]);
      }
      const csv = rows
        .map((r) =>
          r
            .map((x) => String(x).replace(/"/g, '""'))
            .map((x) => `"${x}"`)
            .join(',')
        )
        .join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'td-debugger.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    });

  // JSON export
  const exportJsonBtn = $('exportJson');
  if (exportJsonBtn) {
    exportJsonBtn.addEventListener('click', () => {
      const filterInput = $('filter');
      const q = filterInput ? filterInput.value.trim() : '';
      const filtered = state.entries.filter((e) => matchesFilter(e, q));

      const json = JSON.stringify(filtered, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'td-debugger.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });
  }

  // Pagination controls
  const prevPage = $('prevPage');
  if (prevPage) {
    prevPage.addEventListener('click', () => {
      if (state.currentPage > 0) {
        state.currentPage--;
        renderTable();
      }
    });
  }

  const nextPage = $('nextPage');
  if (nextPage) {
    nextPage.addEventListener('click', () => {
      const filterInput = $('filter');
      const q = filterInput ? filterInput.value.trim() : '';
      const filtered = state.entries.filter((e) => matchesFilter(e, q));
      const maxPage = Math.ceil(filtered.length / state.maxVisible) - 1;
      if (state.currentPage < maxPage) {
        state.currentPage++;
        renderTable();
      }
    });
  }

  const pageSize = $('pageSize');
  if (pageSize) {
    pageSize.addEventListener('change', () => {
      state.maxVisible = parseInt(pageSize.value, 10);
      state.currentPage = 0; // Reset to first page
      renderTable();
    });
  }
})();

// Settings modal
const settingsBtn = $('settingsBtn');
const settingsModal = $('settingsModal');
const settingsJson = $('settingsJson');
const settingsCancel = $('settingsCancel');
const settingsSave = $('settingsSave');
if (settingsBtn && settingsModal && settingsJson && settingsCancel && settingsSave) {
  settingsBtn.addEventListener('click', () => {
    chrome.storage.sync.get(['customFields'], (res) => {
      settingsJson.value = JSON.stringify(res.customFields || {}, null, 2);
      settingsModal.style.display = 'block';
    });
  });
  settingsCancel.addEventListener('click', () => (settingsModal.style.display = 'none'));
  settingsSave.addEventListener('click', () => {
    try {
      const text = settingsJson.value.trim();

      // Validate not empty
      if (!text) {
        showToast('Settings cannot be empty', 'error');
        return;
      }

      // Parse JSON
      const obj = JSON.parse(text);

      // Validate is object
      if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
        showToast('Settings must be a valid object', 'error');
        return;
      }

      // Save
      chrome.storage.sync.set({ customFields: obj }, () => {
        settingsModal.style.display = 'none';
        showToast('Settings saved successfully', 'success');
        renderTable();
      });
    } catch (e) {
      showToast(`Invalid JSON: ${e.message} `, 'error');
    }
  });
}

// Redaction modal
const importBtn = $('importBtn');
const importFileInput = $('importFile');
const exportBtn = $('exportBtn');
const openRedactLink = $('openRedact');
const redactModal = $('redactModal');
const redactArea = $('redactRules');
const redactCancelBtn = $('redactCancel');
const redactSaveBtn = $('redactSave');

if (importBtn && importFileInput) {
  importBtn.addEventListener('click', () => importFileInput.click());
  importFileInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      const allowed = {};
      if (obj.customFields) allowed.customFields = obj.customFields;
      if (obj.redactionRules)
        allowed.redactionRules = Array.isArray(obj.redactionRules) ? obj.redactionRules : [];
      if (obj.tdHosts) allowed.tdHosts = obj.tdHosts;
      if (typeof obj.showNonTD === 'boolean') allowed.showNonTD = obj.showNonTD;
      if (typeof obj.showPreflight === 'boolean') allowed.showPreflight = obj.showPreflight;
      if (typeof obj.tdFilter === 'string') allowed.tdFilter = obj.tdFilter;
      if (typeof obj.tdRedact === 'boolean') allowed.tdRedact = obj.tdRedact;
      chrome.storage.sync.set(allowed, () => {
        renderTable();
        showToast('Settings imported successfully', 'success');
      });
      importFileInput.value = '';
    } catch (err) {
      showToast(`Import failed: ${err.message}`, 'error');
    }
  });
}

if (openRedactLink && redactModal && redactArea && redactCancelBtn && redactSaveBtn) {
  openRedactLink.addEventListener('click', (e) => {
    e.preventDefault();
    chrome.storage.sync.get(['redactionRules'], (res) => {
      const rules = res.redactionRules || [];
      redactArea.value = rules.join('\n');
      redactModal.style.display = 'block';
    });
  });
  redactCancelBtn.addEventListener('click', () => (redactModal.style.display = 'none'));
  redactSaveBtn.addEventListener('click', () => {
    const text = redactArea.value;
    const { valid, errors, lines } = validateRedactionRules(text);

    if (!valid) {
      const errorMsg = `Invalid regex patterns:\n${errors.slice(0, 3).join('\n')}`;
      showToast(errorMsg, 'error', 5000);
      return;
    }

    chrome.storage.sync.set({ redactionRules: lines }, () => {
      redactModal.style.display = 'none';
      const count = lines.length;
      showToast(`Saved ${count} redaction rule${count !== 1 ? 's' : ''}`, 'success');
    });
  });
}

if (exportBtn) {
  exportBtn.addEventListener('click', () => {
    chrome.storage.sync.get(
      [
        'customFields',
        'redactionRules',
        'tdHosts',
        'showNonTD',
        'showPreflight',
        'tdFilter',
        'tdRedact',
      ],
      (res) => {
        const json = JSON.stringify(res, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'td-debugger-settings.json';
        a.click();
        URL.revokeObjectURL(a.href);
      }
    );
  });
}


// ---------- headers modal ----------
/**
 * Show headers modal for an entry
 * @param {Entry} entry - Entry with headers
 */
function showHeadersModal(entry) {
  const modal = $('headersModal');
  if (!modal) return;

  const reqHeaders = $('requestHeadersList');
  const respHeaders = $('responseHeadersList');

  // Populate request headers
  if (reqHeaders) {
    reqHeaders.innerHTML = '';
    const headers = entry.requestHeaders || [];
    if (headers.length === 0) {
      reqHeaders.innerHTML = '<div style="color: #999;">No request headers</div>';
    } else {
      headers.forEach((h) => {
        const item = document.createElement('div');
        item.className = 'header-item';
        if (isImportantHeader(h.name)) {
          item.classList.add('important');
        }
        item.innerHTML = `<strong>${h.name}:</strong> ${h.value}`;
        reqHeaders.appendChild(item);
      });
    }
  }

  // Populate response headers
  if (respHeaders) {
    respHeaders.innerHTML = '';
    const headers = entry.responseHeaders || [];
    if (headers.length === 0) {
      respHeaders.innerHTML = '<div style="color: #999;">No response headers</div>';
    } else {
      headers.forEach((h) => {
        const item = document.createElement('div');
        item.className = 'header-item';
        if (isImportantHeader(h.name)) {
          item.classList.add('important');
        }
        item.innerHTML = `<strong>${h.name}:</strong> ${h.value}`;
        respHeaders.appendChild(item);
      });
    }
  }

  modal.style.display = 'block';

  // Wire up close button
  const closeBtn = $('headersClose');
  if (closeBtn) {
    closeBtn.onclick = () => (modal.style.display = 'none');
  }

  // Wire up copy button
  const copyBtn = $('copyHeaders');
  if (copyBtn) {
    copyBtn.onclick = async () => {
      const reqText = (entry.requestHeaders || [])
        .map((h) => `${h.name}: ${h.value}`)
        .join('\n');
      const respText = (entry.responseHeaders || [])
        .map((h) => `${h.name}: ${h.value}`)
        .join('\n');
      const text = `Request Headers:\n${reqText}\n\nResponse Headers:\n${respText}`;
      await navigator.clipboard.writeText(text);
      showToast('Headers copied to clipboard', 'success');
    };
  }
}

/**
 * Check if header is important (CORS, Auth, Cache)
 * @param {string} name - Header name
 * @returns {boolean} True if important
 */
function isImportantHeader(name) {
  const important = [
    'authorization',
    'access-control-allow-origin',
    'access-control-allow-credentials',
    'access-control-allow-methods',
    'access-control-allow-headers',
    'cache-control',
    'content-type',
    'set-cookie',
    'cookie',
  ];
  return important.includes(name.toLowerCase());
}

// ---------- keyboard navigation ----------
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const settingsModal = $('settingsModal');
    const redactModal = $('redactModal');
    const headersModal = $('headersModal');

    if (settingsModal && settingsModal.style.display === 'block') {
      settingsModal.style.display = 'none';
      const settingsBtn = $('settingsBtn');
      if (settingsBtn) settingsBtn.focus();
    }

    if (redactModal && redactModal.style.display === 'block') {
      redactModal.style.display = 'none';
      const openRedactLink = $('openRedact');
      if (openRedactLink) openRedactLink.focus();
    }

    if (headersModal && headersModal.style.display === 'block') {
      headersModal.style.display = 'none';
    }
  }
});

// ---------- toast notifications ----------
/**
 * Show a toast notification
 * @param {string} message - Message to display
 * @param {string} type - Toast type: 'success', 'error', 'info', 'warning'
 * @param {number} duration - Duration in ms (default: 3000)
 */
function showToast(message, type = 'info', duration = 3000) {
  // Create container if it doesn't exist
  let container = $('toastContainer');
  if (!container) {
    container = document.createElement('div');
    container.id = 'toastContainer';
    container.className = 'toast-container';
    document.body.appendChild(container);
  }

  const toast = document.createElement('div');
  toast.className = `toast toast - ${type} `;
  toast.textContent = message;
  toast.setAttribute('role', 'alert');
  toast.setAttribute('aria-live', 'polite');

  container.appendChild(toast);

  setTimeout(() => toast.classList.add('show'), 10);

  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => {
      if (container.contains(toast)) {
        container.removeChild(toast);
      }
    }, 300);
  }, duration);
}

// ---------- input validation ----------
/**
 * Validate redaction rules
 * @param {string} text - Redaction rules text
 * @returns {{valid: boolean, errors: string[], lines: string[]}}
 */
function validateRedactionRules(text) {
  const lines = text
    .split('\n')
    .map((l) => l.trim())
    .filter(Boolean);
  const errors = [];

  for (let i = 0; i < lines.length; i++) {
    try {
      new RegExp(lines[i]);
    } catch (e) {
      errors.push(`Line ${i + 1}: ${e.message} `);
    }
  }

  return { valid: errors.length === 0, errors, lines };
}

// ---------- init ----------
loadPrefs();
loadCustomExtractors();
attachNetworkListener();
